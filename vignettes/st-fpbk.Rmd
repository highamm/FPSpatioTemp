---
title: "st-fpbk"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{st-fpbk}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Next steps: 
fix all of the "NEED" issues in the vignette
write the other necessary generics (AIC, residuals, etc.)
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>"
)
```

Throughout this vignette, we use the `moose_vignette` data set in the `FPSpatioTemp` package. 

```{r setup}
library(FPSpatioTemp)
moose_vignette
```

The rows of `moose_vignette` correspond to sites for moose surveys in the Tok region of Alaska.  In general, to use this package, a data frame needs to have, at a bare minimum, four variables:

* two variables of spatial coordinates (an x-coordinate and a y-coordinate)
* one variable of a temporal coordinate (such as day, year, etc.)
* the response variable, with `NA` for any `site-time_point` combination that was not surveyed

The four variables required to perform spatio-temporal finite population prediction in the `moose_vignette` data set are:

* `count`, the number of moose in the site (`NA` if the site was not surveyed)
* `xcoords`, spatial x-coordinates, in Trans-Mercator (TM) units
* `ycoord`, spatial y-coordinates, in TM
* `year`, the year of the survey (either `2019`, `2020`, `2021`, or `2022`).

This data set is a subset of the full Tok data set, which contains more sites and has surveys that date back to 1998. There are 112 sites across 4 years, so the data set has a total of 448 rows.

We will use the `ggplot2` package and the `dplyr` package to explore the data:

```{r}
library(ggplot2)
library(dplyr)
```

```{r}
moose_vignette |> group_by(year) |>
  summarise(n_nonmissing = sum(!is.na(count)))
```

We see that between 21 and 27 sites were surveyed in each year. Again, this is a subset of the larger Tok moose surveys data set; we use this subset so that the models fit more quickly in this vignette. 

## The Basics

In this section, we show how to use the `FPSpatioTemp` package with the basic structure of its two main functions: `stlmfit()` and `predict()`.

We use the `stlmfit()` function to fit a spatio-temporal model to the observed count data. There are five arguments: `formula` and `data` arguments similar to those used in `lm()`, and `xcoord`, `ycoord`, and `tcoord` arguments that give the x-coordinates, y-coordinates, and time coordinates. Note that the model takes a few seconds to fit.

```{r}
mod <- stlmfit(formula = count ~ 1, data = moose_vignette,
               xcoord = "xcoords", ycoord = "ycoords",
               tcoord = "year")
mod
```

The printed output gives any estimated fixed effects coefficients (only an `Intercept` in this example) and a table of estimated covariance parameters. To obtain more information about the fitted model, we can use `summary()`:

```{r}
summary(mod)
```

We can now see the formula used to fit the model, summary statistics on the raw residuals, a table of fixed effects coefficients, standard errors, and p-values, a table of estimated covariance parameters, and the correlation functions used for the spatial and temporal correlation components of the model.

The `plot.stlmfit()` generic function can be used to construct a histogram of the residuals and a residuals vs. fitted values plot. The normality assumption would be important to check if we wanted to obtain a prediction interval for a single site or the total for a small number of sites. However, even with skewed errors, we can still predict the abundance on a large number of sites because the total will still follow a normal distribution from an application of the central limit theorem for dependent data.

```{r}
plot(mod)
```

We then use the `predict.stlmfit()` generic function on the fitted model `mod` to, by default, predict the total abundance of moose in the most recent time point of the survey:

```{r}
predict(mod)
```

The output also gives a standard error for the prediction and the bounds of a 90% prediction interval.

#### Other Functionality to `stlmfit()`

The `formula` in `stlmfit()` can be include covariates to be used in the model fitting. For example, in `moose_vignette`, we might consider a model with `strata` as a covariate:

```{r}
mod_strat <- stlmfit(formula = count ~ strata,
                     data = moose_vignette,
                     xcoord = "xcoords", ycoord = "ycoords",
                     tcoord = "year")
mod_strat
```

Two other optional arguments to `stlmfit()` include `cor_model_sp` and `cor_model_t`, which control the correlation function to be used for the spatial and temporal model components, respectively. Options for `cor_model_sp` and `cor_model_t` include `"exponential"` (the default for both), `"spherical"`, `"gaussian"`, and `"cosine"`, among others. The model below uses `strata` as a covariate, a `"spherical"` correlation structure for the spatial correlation, and a `"gaussian"` correlation structure for the temporal correlation.

```{r}
mod_corr <- stlmfit(formula = count ~ strata,
                     data = moose_vignette,
                     xcoord = "xcoords", ycoord = "ycoords",
                     tcoord = "year",
                     cor_model_sp = "spherical",
                     cor_model_t = "spherical")
mod_corr
```

NEED to update error message when incorrect covariance structure is used.

`mod_strat` could then be passed to `predict()`.

NEED to fix error message when elev_mean has all NAs

ADD plot_cov

```{r}
plot_cov(mod_corr, sp_epstol = c(1, 8, 9, 100),
         t_max = 5)
```

#### Other Functionality to `predict()`

The other primary argument of predict is `wts`, which can be used to specify specific weights used for the prediction. Be default, `wts` is a vector of `0`'s and `1`'s with a `1` for any observation in the response in the most recent time point and a `0` otherwise. With the default, we are predicting the total abundance in the most recent time point.

`wts` can either be a vector of the same length as the `data` used in `stlmfit()` or `wts` can be a string giving the name of a column in the `data` used in `stlmfit()`. 

However, we might be interested in predicting the total abundance across all time points. We can specify the `wts` to be a vector of 1's:

```{r}
total_all_years <- rep(1, nrow(moose_vignette))
predict(mod, wts = total_all_years)
```

The `wts` argument can also be used to incorporate sites with unequal areas. The `area_mi` variable in `moose_vignette` gives the area of each site (in square miles):

```{r}
moose_vignette
```

All areas are roughly equal but there is a little variability in site area. To take into account area, we can fit a model on moose __density__ and then give `area_mi` as the `wts` argument in `predict()` so that the densities are transformed back into counts.

```{r}
moose_vignette <- moose_vignette |> 
  mutate(density = count / area_mi)
```

However, if we want the prediction for the total abundance in the current year, we need to create a new vector that is equal to the area for sites in the current year and is a 0 otherwise:

```{r}
moose_vignette <- moose_vignette |>
  mutate(area_current = if_else(year == max(year),
                                true = area_mi,
                                false = 0))
```

FIX THIS ERROR
```{r}
# mod_density <- stlmfit(formula = count / area_mi ~ 1,
#                        data = moose_vignette,
#                        xcoord = "xcoords", ycoord = "ycoords",
#                        tcoord = "year")
mod_density <- stlmfit(formula = density ~ 1,
                       data = moose_vignette,
                       xcoord = "xcoords", ycoord = "ycoords",
                       tcoord = "year")
              
mod_density
```

If we want the prediction for the total abundance across all years, we can use `area_mi` directly:

```{r}
predict(mod_density, wts = "area_current")
predict(mod)
```

Note that the prediction for the total abundance in 2022 incorporating area and not incorporating area are nearly identical because the site areas in the data are nearly identical. 

Other variables in the data frame could include relevant covariates to be used in the model, the area of each spatial site, or a variable indicating whether sites were in the sampling frame for that particular survey. In the moose data set, both `Stratname` and `ELEV_MEAN` could be used as covariates, `AreaMi` gives the area of each site, in square miles, and `samp_frame` is an indicator for whether a site was in the sampling frame for the particular survey:

```{r}
moose_complete |> select(xcoords, ycoords, Surveyyear, totalmoosena,
                         Stratname, ELEV_MEAN, AreaMi, samp_frame)

```

#### Missing

* for any site not surveyed or observed, the response variable should be `NA` (not `0`, `-999`, or any other missing value convention). The variable type should be `<dbl>` or `<int>`.

For example,

```{r}
summary(moose_complete$totalmoosena)
```

#### Column with Prediction Weights

* one column in the data frame should have prediction weights. Most commonly, this column will be a variable that takes on a `1` for any site in the sampling frame in the most recent time point of the survey and a `0` otherwise so that the prediction that is output is for the total response in the most current time point.

For example, the moose data set has a variable `samp_frame` that is a `1` if the site was in that year's sampling frame and a `0` otherwise. Note that, in some applications, the sampling frame does not change at all from year to year, in which case we can ignore this variable. However, the moose survey sampling frame changed in 2014, when biologists focused their survey efforts on a different area than they did before 2014. 

```{r}
moose_complete <- moose_complete |>
  mutate(predweights_22 = if_else(Surveyyear == 2022 & samp_frame == 1,
                                  true = 1, 
                                  false = 0)) 
```

## example with 2022 data

```{r}

moose_prep <- moose_complete |>
## use most recent stratification
  mutate(newstrat = if_else(Surveyyear == 2022,
                            true = stratfact, 
                            false = NA_integer_)) |>
  dplyr::group_by(ID) |> fill(newstrat, .direction = "updown") |>
  ungroup()

## only use data from sites within 2022's sampling frame

moose_df_merge <- moose_prep |>
  filter(predweights_22 == 1) |> select(ID)
moose_final_all <- semi_join(moose_prep, moose_df_merge)

moose_final_all |> filter(Surveyyear >= 2014) |>
  group_by(stratfact) |>
  summarise(n())
  ##summarise(sum(!is.na(totalmoosena)))
## 2018 has a very large outlier, driving up the
## variability in the predictor
## newstrat uses the stratum from 2022
mod_22 <- stlmfit(formula = totalmoosena ~ stratfact,
                  data = moose_final_all |> filter(Surveyyear >= 2016),
                  xcoord = "xcoords",
                  ycoord = "ycoords",
                  tcoord = "Surveyyear")

pred_obj_all <- predict(object = mod_22, wtscol = "predweights_22")
pred_obj_all$totalpred
pred_obj_all$predvar |> sqrt()

library(sptotal)
moose_22_sptotal <- moose_18_22 |>
  filter(predweights_22 == 1) 
mod_sptot <- slmfit(totalmoosena ~ newstrat,
                  data = moose_22_sptotal,
                  xcoord = "xcoords",
                  ycoord = "ycoords")
pred_sptot <- predict(mod_sptot)
pred_sptot$FPBK_Prediction
pred_sptot$PredVar |> sqrt()
```

## adding covariates

## constructing plots



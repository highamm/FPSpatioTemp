---
title: "st-fpbk"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{st-fpbk}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>"
)
```

Throughout this vignette, we use the `moose_vignette` data set in the `FPSpatioTemp` package. 

```{r setup}
library(FPSpatioTemp)
moose_vignette
```

The rows of `moose_vignette` correspond to sites for moose surveys in the Tok region of Alaska.  In general, to use this package, a data frame needs to have, at a bare minimum, four variables:

* two variables of spatial coordinates (an x-coordinate and a y-coordinate)
* one variable of a temporal coordinate (such as day, year, etc.)
* the response variable, with `NA` for any `site-time_point` combination that was not surveyed

The four variables required to perform spatio-temporal finite population prediction in the `moose_vignette` data set are:

* `count`, the number of moose in the site (`NA` if the site was not surveyed)
* `xcoords`, spatial x-coordinates, in Trans-Mercator (TM) units
* `ycoord`, spatial y-coordinates, in TM
* `year`, the year of the survey (either `2019`, `2020`, `2021`, or `2022`).

This data set is a subset of the full Tok data set, which contains more sites and has surveys that date back to 1998. There are 112 sites across 4 years, so the data set has a total of 448 rows.

We will use the `ggplot2` package and the `dplyr` package to explore the data:

```{r}
library(ggplot2)
library(dplyr)
```

```{r}
moose_vignette |> group_by(year) |>
  summarise(n_nonmissing = sum(!is.na(count)))
```

We see that between 21 and 27 sites were surveyed in each year. Again, this is a subset of the larger Tok moose surveys data set; we use this subset so that the models fit more quickly in this vignette. 

## The Basics

In this section, we show how to use the `FPSpatioTemp` package with the basic structure of its two main functions: `stlmfit()` and `predict()`.

We use the `stlmfit()` function to fit a spatio-temporal model to the observed count data. There are five arguments: `formula` and `data` arguments similar to those used in `lm()`, and `xcoord`, `ycoord`, and `tcoord` arguments that give the x-coordinates, y-coordinates, and time coordinates. Note that the model takes a few seconds to fit.

```{r}
mod <- stlmfit(formula = count ~ 1, data = moose_vignette,
               xcoord = "xcoords", ycoord = "ycoords",
               tcoord = "year")
mod
```

The output.....(NEED to update the print generic for stlmfit())

NEED to create a summary generic for stlmfit()

We then use the fitted model `mod` to, by default, predict the total abundance of moose in the most recent time point of the survey:

```{r}
predict(mod)
```

NEED to update print generic for predict()

The output also gives a standard error for the prediction and the bounds of a 90% prediction interval.

```{r}
total_all_years <- rep(1, nrow(moose_vignette))
predict(mod, wts = total_all_years)
```

#### Other Functionality to `stlmfit()`

The `formula` in `stlmfit()` can be include covariates to be used in the model fitting. For example, in `moose_vignette`, we might consider a model with `strata` as a covariate:

```{r}
mod_strat <- stlmfit(formula = count ~ strata,
                     data = moose_vignette,
                     xcoord = "xcoords", ycoord = "ycoords",
                     tcoord = "year")
mod_strat
```

Two other optional arguments to `stlmfit()` include `cor_model_sp` and `cor_model_t`, which control the correlation function to be used for the spatial and temporal model components, respectively. Options for `cor_model_sp` and `cor_model_t` include `"exponential"` (the default for both), `"spherical"`, `"gaussian"`, and `"cosine"`, among others. The model below uses `strata` as a covariate, a `"spherical"` correlation structure for the spatial correlation, and a `"gaussian"` correlation structure for the temporal correlation.

```{r}
mod_corr <- stlmfit(formula = count ~ strata,
                     data = moose_vignette,
                     xcoord = "xcoords", ycoord = "ycoords",
                     tcoord = "year",
                     cor_model_sp = "spherical",
                     cor_model_t = "gaussian")
mod_corr
```

NEED to modify print to say which correlation function was used

NEED to update error message when incorrect covariance structure is used.

NEED to change this: write now, can only use the four covariance functions that Mike uses (exponential, gaussian, spherical, tent).

`mod_strat` could then be passed to `predict()`.

NEED to write residuals function

NEED to fix error message when elev_mean has all NAs

NEED to write AIC function


Other variables in the data frame could include relevant covariates to be used in the model, the area of each spatial site, or a variable indicating whether sites were in the sampling frame for that particular survey. In the moose data set, both `Stratname` and `ELEV_MEAN` could be used as covariates, `AreaMi` gives the area of each site, in square miles, and `samp_frame` is an indicator for whether a site was in the sampling frame for the particular survey:

```{r}
moose_complete |> select(xcoords, ycoords, Surveyyear, totalmoosena,
                         Stratname, ELEV_MEAN, AreaMi, samp_frame)

```

#### Missing

* for any site not surveyed or observed, the response variable should be `NA` (not `0`, `-999`, or any other missing value convention). The variable type should be `<dbl>` or `<int>`.

For example,

```{r}
summary(moose_complete$totalmoosena)
```

#### Column with Prediction Weights

* one column in the data frame should have prediction weights. Most commonly, this column will be a variable that takes on a `1` for any site in the sampling frame in the most recent time point of the survey and a `0` otherwise so that the prediction that is output is for the total response in the most current time point.

For example, the moose data set has a variable `samp_frame` that is a `1` if the site was in that year's sampling frame and a `0` otherwise. Note that, in some applications, the sampling frame does not change at all from year to year, in which case we can ignore this variable. However, the moose survey sampling frame changed in 2014, when biologists focused their survey efforts on a different area than they did before 2014. 

```{r}
moose_complete <- moose_complete |>
  mutate(predweights_22 = if_else(Surveyyear == 2022 & samp_frame == 1,
                                  true = 1, 
                                  false = 0)) 
```

## example with 2022 data

```{r}

moose_prep <- moose_complete |>
## use most recent stratification
  mutate(newstrat = if_else(Surveyyear == 2022,
                            true = stratfact, 
                            false = NA_integer_)) |>
  dplyr::group_by(ID) |> fill(newstrat, .direction = "updown") |>
  ungroup()

## only use data from sites within 2022's sampling frame

moose_df_merge <- moose_prep |>
  filter(predweights_22 == 1) |> select(ID)
moose_final_all <- semi_join(moose_prep, moose_df_merge)

moose_final_all |> filter(Surveyyear >= 2014) |>
  group_by(stratfact) |>
  summarise(n())
  ##summarise(sum(!is.na(totalmoosena)))
## 2018 has a very large outlier, driving up the
## variability in the predictor
## newstrat uses the stratum from 2022
mod_22 <- stlmfit(formula = totalmoosena ~ stratfact,
                  data = moose_final_all |> filter(Surveyyear >= 2016),
                  xcoord = "xcoords",
                  ycoord = "ycoords",
                  tcoord = "Surveyyear")

pred_obj_all <- predict(object = mod_22, wtscol = "predweights_22")
pred_obj_all$totalpred
pred_obj_all$predvar |> sqrt()

library(sptotal)
moose_22_sptotal <- moose_18_22 |>
  filter(predweights_22 == 1) 
mod_sptot <- slmfit(totalmoosena ~ newstrat,
                  data = moose_22_sptotal,
                  xcoord = "xcoords",
                  ycoord = "ycoords")
pred_sptot <- predict(mod_sptot)
pred_sptot$FPBK_Prediction
pred_sptot$PredVar |> sqrt()
```

## adding covariates

## constructing plots


